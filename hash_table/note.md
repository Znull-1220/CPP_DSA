# hash table

## 原理
通过哈希函数将关键字映射到哈希表中的一个位置，然后在这个位置存储关键字对应的值。

## hash collision 及其解决

拉链法/线性探测法

### 拉链法
是在后面加一个链表，关键是合理选择hash table的大小，使得每个链表的长度尽量短，也不会产生太多哈希表的空间浪费。

### 线性探测法
是在后面找一个空的位置，关键是合理选择hash table的大小，使得每个位置的探测次数尽量少。
此时tableSize大于dataSize， 否则没有空位来解决冲突问题。

## 常用data structure
数组, map, set

[代码随想录-常见哈希结构](https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84)


| 数据结构                                      | 底层实现 | 特点             |
|-------------------------------------------|------|----------------|
| std::unordered_map<br/>std::unordered_set | 哈希表  | 无序，不允许重复       |
| std::map<br/>std::set                     | 红黑树  | 有序，不允许重复       |
| std::multimap<br/>std::multiset           | 红黑树  | 有序，允许重复元素(key) |

注意红黑树实现中key是不能改动的，它是二叉平衡搜索树，如果key改变了，那么树的结构就会改变导致树错乱，所以只能增删元素。
而且红黑树实现key也是有序的


## 应用
遇到要快速判断一个元素是否出现在集合/需要判断一个元素是否出现过

但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速查找。

## 总结
数据有限定范围(比如字母)用数组是最好的，因为map/set还要维护额外的数据结构，空间复杂度高；

数据范围大且不连续，用set，unordered_set 读写效率是最高的

map适合与要记录下标的情况，是一个key-value对

还有，三数/四数之和这样的题目并不适合用哈希，用双指针会更容易去重。但是要注意用双指针之前一定要sort元素，
因为双指针法使用的前提就是有序的数组。
