# 回溯 Backtracking
# Overview
回溯是递归的副产品 只要有递归，就会有回溯。

回溯其实就是暴力搜索，它的时间复杂度并不低。 因为回溯的本质是穷举，
穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以
加一些剪枝，但也改不了回溯法就是穷举的本质。

递归时间复杂度 = 递归函数时间复杂度 * 递归次数

它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇
到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止。

回溯涉及尝试与回退，当当前条件不满足时，会回退到上一步，尝试其他的选择。

可以采用约束条件来pruning.

## 常见问题

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

组合无序，排列有序

所有回溯问题都可以抽象为树形结构(高度有限N叉树) 递归次数有限->高度有限；集合大小决定树宽度
## template
```
// arg always include path, choices 路径&选择列表
void backtracking(args) {
    // 终止条件 深度有限
    if (终止条件) {
        存放结果;   result.push_back(path);
        return;
    }

    // aka 选择 : 选择列表
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点 即做选择; 
        backtracking(路径，选择列表); // 递归
        回溯，撤销选择;
    }
}

```
