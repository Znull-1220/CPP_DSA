# Dynamic Programming

## Overview
### 动规与贪心的区别
动态规划当前解依赖与上一步，而贪心是在每一步都找到局部最优解。

### 方法论
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

### Debug
确认dp数组与自己的理解是否一致，而不要黑盒式地理解


## 背包问题
0-1背包， 完全背包， 多重背包 

区别就是在于物品的数量，0-1是每个物品只有一个，完全背包是每个物品有无限个，多重背包是每个物品有有限个。
### 01背包
只有拿或者不拿两种情况

暴力解法：回溯

#### 递推公式
dp解法：需要一个二维数组，dp[i][j]就是在前i个物品中任取，背包容量为j时的最大价值

不放物品i 最大价值是dp[i - 1][j]; 放物品i 最大价值是放物品i的价值 + 放物品i后剩余空间能放的最大价值 
即为 dp[i - 1][j - weight[i]] + value[i]

dp递推公式即为 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

#### dp数组初始化
按照递推公式，数组中的元素可能是根据**同一列正上方的元素**或者**上一行 同列之前的元素**递推得来，所以首先第一列与第一行一定要初始化。

第一列表示背包容量为0，那么dp[i][0] = 0，因为背包容量为0，那么无论有多少物品，价值都是0

第一行当dp[0][j] j > weight[0] 时，表示只有一个物品，那么只有当背包容量大于等于第一个物品的重量时，才能放入，否则价值为0

非0下标其实初始化成什么都可以，不会影响结果 因为是递推得来的

#### 遍历顺序
如果是2D dp数组，那么先遍历物品/背包都是可以的

但对于1D dp数组，如果是从前往后遍历，那么会影响到后面的结果，所以必须从后往前遍历，
而且必须先遍历物品，再遍历背包，防止同一物品被放入两次。

#### 0-1背包 组合问题
上面是求最大装满 dp[i][j]的含义是 在前i个物品中任取，背包容量为j时的最大价值

组合背包适用于组合类问题，求有多少种方法可以装满背包。dp[i][j]的含义是在前i个物品中任取，背包容量为j时的方法数,
递推公式为
```c++ 
// 1. 装不下物品i时
dp[i][j] = dp[i - 1][j]
// 2. 装得下物品i时 就是之前的方法数加上装入物品i后 剩余容量可用的方法数
dp[i][j] = dp[i - 1][j] + dp[i][j - weight[i]]
```
装不满，装不下都是不行的，而且这里初始化也有区别，容量为0时，只有一种方法，就是什么都不装，所以dp[0][j] = 1

求装满背包有多少种方法，都用这样的递推公式.

0-1背包 组合问题例题：[目标和](./target_sum.cpp)

### 完全背包
每个物品可以无限次放入背包

1D dp数组实现，与0-1背包的遍历顺序不同，**正序遍历背包容量**就是完全背包。

还有完全背包的1D dp数组实现的遍历顺序也是可以颠倒的，先遍历物品/背包都是可以的。

模板题目：[完全背包](./complete_knapsack.cpp)

#### 题目总结

虽然纯完全背包先遍历物品/背包都可以，但具体情况还会出现变化。

1. 组合问题 无所谓内部排列的顺序，**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。 如题目[动态规划：518.零钱兑换II](./coin_change_ii.cpp)
2. 排列问题 内部排列的顺序不同，那么就是不同方案。**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。 如题目[动态规划：377.组合总和IV](./combination_sum_iv.cpp)、[爬楼梯进阶](./climbing_stairs_ii.cpp)
3. 求组合最小值 这时无所谓组合/排列，如题目[动态规划：322.零钱兑换](./coin_change.cpp), [动态规划：279.完全平方数](./perfect_squares.cpp)。
这里因为递推公式也变成了```dp[j] = min(dp[j], dp[j - nums[i]] + 1)```, 所以初始化dp数组时，要初始化为最大值，这样才能保证递推公式的正确性。以及dp[0]一般
都初始化为1了，可以根据后面的元素递推测试一下。比如$i = nums[i]$的情况，根据递推公式dp[j]应该是多少，就可以确定dp[0].
### 多重背包
多种物品，每个物品有有限个。做法就是将多重背包转化为0-1背包，将每个物品拆分成多个物品，然后使用0-1背包的方法。

## 经典问题

### 打家劫舍
- [LC #198.打家劫舍](./house_robber.cpp): 一个数组，相邻的两个元素不能同时取，求最大值
- [LC #213.打家劫舍II](./house_robber_ii.cpp): 一个数组，首尾相连，相邻的两个元素不能同时取->只需考虑两种情况，一种是不取第一个元素，一种是不取最后一个元素。
最后取两种情况的最大值即可 那么就转化为打家劫舍I的问题
- [LC #337.打家劫舍III](./house_robber_iii.cpp): 树形DP 暴力递归和DP两种解法 其实DP解法挺简单直接的，只需要一个二维数组dp[i][2]表示当前节点取或者不取的最大值即可。
注意是后序遍历，因为需要返回值来判断到底偷还是不偷当前节点。
### 股票问题
股票问题基本思路：分析每一天可能出现的状态，dp数组为每一天开相同的状态数，所以最基本的就是要分清有多少种状态：最简单的就是第$i$天持有或不持有
- [LC #121.买卖股票的最佳时机](best_time_to_buy_and_sell_stock.cpp)
- [LC #122.买卖股票的最佳时机II](best_time_to_buy_and_sell_stock_ii.cpp): 可以多次买卖，那么每次购入时要加上之前卖出的利润进行状态转移；
- [LC #123.买卖股票的最佳时机III](best_time_to_buy_and_sell_stock_iii.cpp): 最多可以买卖两次—>四种状态(买入1，卖出1，买入2，卖出2)
- [LC #188.买卖股票的最佳时机IV](best_time_to_buy_and_sell_stock_iv.cpp): 延续上一题，最多可以买卖k次，那么就有2k种状态；但是为了for-loop递推方便，可以增加一个0状态，即什么操作都不做
- [LC #309.最佳买卖股票时机含冷冻期](best_time_to_buy_and_sell_stock_with_cooldown.cpp)
- [LC #714.买卖股票的最佳时机含手续费](best_time_to_buy_and_sell_stock_with_transaction_fee.cpp)

只要画出状态机，然后根据状态机写出状态转移方程，就可以解决这类问题。以及初始化时要根据状态对应的意义初始dp[0][j].
### 子序列问题
子序列问题一般最好用dp[i][j]去表示两个字符串的第i - 1和第j - 1个字符结尾的子序列，这样可以避免初始化，代码实现简单。
- [LC #300.最长递增子序列](./longest_increasing_subsequence.cpp)
- [LC #674.最长连续递增序列](./longest_continuous_increasing_subsequence.cpp)
- [LC #718.最长重复子数组](./maximum_length_of_repeated_subarray.cpp)
- [1143.最长公共子序列](./longest_common_subsequence.cpp); 这道题和[LC #1035.不相交的线不相交的线](https://leetcode.cn/problems/uncrossed-lines/description/)
本质上是一样的，不相交的线其实就是不改变字符在字符串中的相对位置才可以连线，就是求最长公共子序列。
- [LC #53.最大子序和](./maximum_subarray_dp.cpp),贪心也可以做[LC #53.最大子序和-贪心解法](../greedy_algorithm/maximum_subarray.cpp). DP解法简单直观！
#### 编辑距离
涉及增删改的问题 初始化这时候也不太一样了，需要根据意义分析一下，比如说一个串要删除到空串，需要将全部字符删除等等。
- [LC #47.判断子序列](./is_subsequence.cpp)：编辑距离入门，可以用DP解决，也可以用双指针解决。
- [LC #115.不同的子序列](./distinct_subsequences.cpp)
- [LC #583.两个字符串的删除操作](delete_operation_for_two_strings.cpp): 两个字符串都可以任意删除，状态转移方程在字符不相等的时候就是两种类别！
- [LC #72.编辑距离](./edit_distance.cpp): 两个字符串的编辑距离，可以增删改，状态转移方程也是根据字符是否相等来分类讨论的。
在不相等的时候，有三种操作: 增删改，所以状态转移方程也是三种情况的最小值。
#### 回文子序列
- [LC #647.回文子串](palindromic_substrings.cpp)
- [LC #516.最长回文子序列](longest_palindromic_subsequence.cpp)

总结：
- 回文子序列一般用dp[i][j]表示第i个字符到第j个字符的xx回文子序列 定义明确；
- $s.t.\quad $  $i \leq j$ , 所以dp table一定是个上三角阵；
- 遍历顺序 从dp的状态转移方程 可以很容易看出来是从下往上，从左往右遍历的；（具体情况具体分析），此外遍历的区间也可以从dp的定义中看出来；
- 回文的思路就是 两边扩散，所以状态转移方程也是根据两边字符是否相等来分类讨论。

