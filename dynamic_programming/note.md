# Dynamic Programming

## Overview
### 动规与贪心的区别
动态规划当前解依赖与上一步，而贪心是在每一步都找到局部最优解。

### 方法论
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

### Debug
确认dp数组与自己的理解是否一致，而不要黑盒式地理解


## 背包问题
0-1背包， 完全背包， 多重背包 

区别就是在于物品的数量，0-1是每个物品只有一个，完全背包是每个物品有无限个，多重背包是每个物品有有限个。
### 01背包
只有拿或者不拿两种情况

暴力解法：回溯

#### 递推公式
dp解法：需要一个二维数组，dp[i][j]就是在前i个物品中任取，背包容量为j时的最大价值

不放物品i 最大价值是dp[i - 1][j]; 放物品i 最大价值是放物品i的价值 + 放物品i后剩余空间能放的最大价值 
即为 dp[i - 1][j - weight[i]] + value[i]

dp递推公式即为 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

#### dp数组初始化
按照递推公式，数组中的元素可能是根据**同一列正上方的元素**或者**上一行 同列之前的元素**递推得来，所以首先第一列与第一行一定要初始化。

第一列表示背包容量为0，那么dp[i][0] = 0，因为背包容量为0，那么无论有多少物品，价值都是0

第一行当dp[0][j] j > weight[0] 时，表示只有一个物品，那么只有当背包容量大于等于第一个物品的重量时，才能放入，否则价值为0

非0下标其实初始化成什么都可以，不会影响结果 因为是递推得来的

#### 遍历顺序
如果是2D dp数组，那么先遍历物品/背包都是可以的

但对于1D dp数组，如果是从前往后遍历，那么会影响到后面的结果，所以必须从后往前遍历，
而且必须先遍历物品，再遍历背包，防止同一物品被放入两次。